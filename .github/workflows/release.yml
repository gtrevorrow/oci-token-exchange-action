name: Release

on:
  workflow_run:
    workflows: ["Build and Commit"] # Name of the triggering workflow
    types:
      - completed
    branches: # Filters for the branch the "Build and Commit" workflow ran on
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    # Condition to ensure this job only runs if the triggering workflow ("Build and Commit")
    # was itself triggered by a 'push' event to 'main' and completed successfully.
    if: github.event.workflow_run.event == 'push' && github.event.workflow_run.conclusion == 'success'
    permissions:
      # Needs write access to create releases, read packages, and write for discussions (for notes)
      contents: 'write'
      packages: 'read'
      discussions: 'write'
      # Pull requests permission is used to comment on PRs mentioned in release notes
      pull-requests: 'write'
      # Issues permission is used to comment on issues being closed in the release
      issues: 'write'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: main # Explicitly check out the latest main branch
          fetch-depth: 0 # Ensure full history is fetched
          # token: ${{ secrets.SEMANTIC_RELEASE_PAT }} # Optional: use PAT if default GITHUB_TOKEN has issues with workflow_run checkout, but usually not needed for same repo.

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install Dependencies
        run: npm ci

      - name: Build Project
        run: npm run build

      - name: Run tests
        run: npm test

      - name: Run Semantic Release
        id: semantic
        run: |
          npx semantic-release > semantic-release-output.json || true 
          # '|| true' ensures the step doesn't fail if semantic-release exits with a non-zero code when no release is made.
          # We'll check the content of semantic-release-output.json to determine if a release happened.
        env:
          GITHUB_TOKEN: ${{ secrets.SEMANTIC_RELEASE_PAT }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Set Semantic Release Outputs
        id: sr_outputs
        run: |
          echo "--- Debug: Initial content of semantic-release-output.json ---"
          if [ -f semantic-release-output.json ]; then
            cat semantic-release-output.json
          else
            echo "semantic-release-output.json does NOT exist at the start of the step."
          fi
          echo "--- End of initial content ---"

          if [ -f semantic-release-output.json ] && [ -s semantic-release-output.json ]; then
            # Attempt to extract JSON content, assuming it starts with '{' and is at the end
            # This helps if there's leading non-JSON text (like logs) in the file.
            JSON_CANDIDATE=$(sed -n '/^{/,$p' semantic-release-output.json)

            if [ -n "$JSON_CANDIDATE" ] && echo "$JSON_CANDIDATE" | jq -e . > /dev/null; then
              echo "Successfully extracted and validated JSON from semantic-release-output.json."
              echo "--- Extracted JSON content ---"
              echo "$JSON_CANDIDATE"
              echo "--- End of extracted JSON content ---"

              VERSION=$(echo "$JSON_CANDIDATE" | jq -r '.nextRelease.version // ""')
              NOTES_RAW=$(echo "$JSON_CANDIDATE" | jq -r '.nextRelease.notes // ""')
              
              if [ -n "$VERSION" ]; then
                echo "new_release_published=true" >> $GITHUB_OUTPUT
                echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
                
                # Set multiline notes using heredoc for GITHUB_OUTPUT
                echo "new_release_notes<<EOF_NOTES" >> $GITHUB_OUTPUT
                echo "$NOTES_RAW" >> $GITHUB_OUTPUT
                echo "EOF_NOTES" >> $GITHUB_OUTPUT

                echo "Successfully parsed release information: Version $VERSION"
              else
                echo "No new release version found in the extracted JSON (.nextRelease.version was empty or null)."
                echo "new_release_published=false" >> $GITHUB_OUTPUT
                echo "new_release_version=" >> $GITHUB_OUTPUT
                echo "new_release_notes=" >> $GITHUB_OUTPUT
              fi
            else
              echo "Failed to extract or validate JSON from semantic-release-output.json."
              echo "Original file content was (if any):"
              cat semantic-release-output.json || echo "File was empty or unreadable."
              echo "Attempted JSON extraction (JSON_CANDIDATE was):"
              echo "$JSON_CANDIDATE"
              echo "new_release_published=false" >> $GITHUB_OUTPUT
              echo "new_release_version=" >> $GITHUB_OUTPUT
              echo "new_release_notes=" >> $GITHUB_OUTPUT
            fi
          else
            echo "semantic-release-output.json does not exist or is empty."
            echo "new_release_published=false" >> $GITHUB_OUTPUT
            echo "new_release_version=" >> $GITHUB_OUTPUT
            echo "new_release_notes=" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Get released version
        # Check if the new 'Set Semantic Release Outputs' step indicates a release
        if: steps.sr_outputs.outputs.new_release_published == 'true'
        run: |
          echo "RELEASE_VERSION=${{ steps.sr_outputs.outputs.new_release_version }}" >> $GITHUB_ENV
          echo "New version released: ${{ steps.sr_outputs.outputs.new_release_version }}"

      # Add a step to debug outputs if the problem persists
      - name: Dump semantic-release outputs
        if: always()
        run: |
          echo "Semantic Release Outputs (from sr_outputs step):"
          echo "new_release_published: ${{ steps.sr_outputs.outputs.new_release_published }}"
          echo "new_release_version: ${{ steps.sr_outputs.outputs.new_release_version }}"
          # echo "new_release_notes: ${{ steps.sr_outputs.outputs.new_release_notes }}" # Notes can be very long
          if [ -n "${{ steps.sr_outputs.outputs.new_release_notes }}" ]; then
            echo "new_release_notes are set (not printing full content)."
          else
            echo "new_release_notes are empty."
          fi

      # Add steps to update major version tag
      - name: Update Major Version Tag (e.g., v1)
        if: env.RELEASE_VERSION # Only run if a new version was released
        run: |
          # Extract the major version number (e.g., "1" from "v1.2.3")
          MAJOR_VERSION=$(echo $RELEASE_VERSION | sed -E 's/v([0-9]+)\..*/\1/')
          MAJOR_TAG="v$MAJOR_VERSION"
          echo "Updating tag $MAJOR_TAG to point to $RELEASE_VERSION"
          # Configure git user for this push
          git config --global user.name "semantic-release-bot"
          git config --global user.email "semantic-release-bot@users.noreply.github.com"
          # Create or update the major version tag locally, pointing to the same commit as the release version tag
          git tag -f $MAJOR_TAG $RELEASE_VERSION 
          # Force push the major version tag to the remote
          git push --force https://x-access-token:${{ secrets.SEMANTIC_RELEASE_PAT }}@github.com/${{ github.repository }} $MAJOR_TAG
        env:
          # GITHUB_TOKEN is not directly used by git push here, explicit token in URL
          RELEASE_VERSION: ${{ env.RELEASE_VERSION }}


      - name: Update latest tag
        # Only run if a new version was released (RELEASE_VERSION is set)
        if: env.RELEASE_VERSION 
        run: |
          echo "Updating latest tag to point to $RELEASE_VERSION"
          # Configure git user for this push (if not already done globally in job)
          git config --global user.name "semantic-release-bot"
          git config --global user.email "semantic-release-bot@users.noreply.github.com"
          # Create or update the latest tag locally, pointing it to the same commit as the release version tag
          git tag -f latest $RELEASE_VERSION 
          # Force push the latest tag to the remote
          git push --force https://x-access-token:${{ secrets.SEMANTIC_RELEASE_PAT }}@github.com/${{ github.repository }} latest
        env:
          # GITHUB_TOKEN is not directly used by git push here, explicit token in URL
          RELEASE_VERSION: ${{ env.RELEASE_VERSION }}
